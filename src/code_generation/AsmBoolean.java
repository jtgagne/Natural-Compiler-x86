package code_generation;

import inter.Id;
import inter.Stmt;
import lexer.Tag;
import lexer.Token;
import symbols.Type;

/**
 * Class used for organizing various boolean expressions to be generated by the compiler
 * Created by gagnej3 on 11/29/16.
 */
public class AsmBoolean {

    private static String mResultRegister;

    /**
     * Branch if expression is false
     * @param register register containing a boolean 1 or 0
     * @return the formatted String
     */
    public static String genBranchTo(String register){
        Stmt s = Stmt.Enclosing;
        String label = s.getLabelAfter();   //Get the enclosing label of the current statement
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("\tCMP\t %s, %s\t\t; Check if true\n", register, AsmConstants.BOOLEAN_TRUE));
        sb.append(String.format("\tJNE\t %s\n", label));
        return sb.toString();
    }

    public static String genCompare(String register1, String register2, Type type){
        String result = "";
        if(type == Type.Double || type == Type.Float){
            result += String.format("\tFCOMPP\n");
            result += String.format("\tFNSTSW ax\n");
            result += "\tSAHF\n";
        } else{
            result = String.format("\tCMP\t %s, %s\n", register1, register2);
        }
        mResultRegister = register1;
        RegisterManager.freeRegister(register2);
        return result;
    }

    public static String genRelationalJump(Token relation, Type exprType){
        if(exprType == Type.Double || exprType == Type.Float){
            return genRelationalJumpFloats(relation);
        }
        return genRelationalJumpWhole(relation);
    }

    private static String genRelationalJumpFloats(Token relation){
        Stmt s = Stmt.Enclosing;
        String label = s.getLabelAfter();   //Get the enclosing label of the current statement
        switch (relation.tag){
            case Tag.LESS:
                return String.format("\tJBE\t %s\n", label);
            case Tag.GREATER:
                return String.format("\tJAE\t %s\n", label);
            case Tag.GE:
                return String.format("\tJB\t %s\n", label);
            case Tag.LE:
                return String.format("\tJNLE\t %s\n", label);
            case Tag.EQ:
                return String.format("\tJNE\t %s\n", label);
            case Tag.NE:
                return String.format("\tJE\t %s\n", label);
        }
        return "";
    }

    private static String genRelationalJumpWhole(Token relation){
        Stmt s = Stmt.Enclosing;
        String label = s.getLabelAfter();   //Get the enclosing label of the current statement
        switch (relation.tag){
            case Tag.LESS:
                //return String.format("\tJNL\t %s\n", label);
                //return String.format("\tJNE\t %s\n", label);
                return genLastRelationalJump(label);
            case Tag.GREATER:
                //return String.format("\tJNG\t %s\n", label);
                return genLastRelationalJump(label);

            case Tag.GE:
                //return String.format("\tJNGE\t %s\n", label);
                return genLastRelationalJump(label);
            case Tag.LE:
                //return String.format("\tJNLE\t %s\n", label);
                return genLastRelationalJump(label);
            case Tag.EQ:
                //return String.format("\tJNE\t %s\n", label);
                return genLastRelationalJump(label);
            case Tag.NE:
                //return String.format("\tJE\t %s\n", label);
                return genLastRelationalJump(label);
        }
        return "";
    }

    public static String genAndExpr(String register1, String register2) {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("\tAND\t %s, %s\n", register1, register2));
        mResultRegister = register1;
        RegisterManager.freeRegister(register2);
        return sb.toString();
    }


    public static String genOrExpr(String register1, String register2){
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("\tOR\t %s, %s\n", register1, register2));
        mResultRegister = register1;
        RegisterManager.freeRegister(register2);
        return sb.toString();
    }

    public static String genNotExpr(String register1){
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("\tNOT\t %s\t; execute a bitwise not on the register\n", register1));
        mResultRegister = register1;
        return sb.toString();
    }

    /**
     * @return the name of the register that a result was recently stored in.
     */
    public static String getResultRegister(){
        return mResultRegister;
    }

    /**
     * Pushes eax and ebx if in use
     * @param id1 first identifier
     * @param id2 second identifier
     * @return the string to be appended
     */
    public static String evaluateRelational(Id id1, Id id2, String macroName){
        StringBuilder sb = new StringBuilder();
        Register eax = Register.EAX;
        Register ebx = Register.EBX;
        String popEax = "";
        String popEbx = "";

        //Push registers if necessary
        if(RegisterManager.isInUse(eax)){
            sb.append(String.format("\tPUSH %s\n", eax.name));
            popEax = String.format("\tPOP %s\n", eax.name);
        }
        if(RegisterManager.isInUse(ebx)){
            sb.append(String.format("\tPUSH %s\n", ebx.name));
            popEbx = String.format("\tPOP %s\n", ebx.name);
        }
        sb.append(String.format("\tMOV %s, 00000000h\n", eax.name));
        sb.append(String.format("\tMOV %s, 00000000h\n", ebx.name));

        if(id1.getType() != Type.Long){
            sb.append(String.format("\tMOVSX %s, %s\n", eax.name, id1.getName()));
            sb.append(String.format("\tMOVSX %s, %s\n", ebx.name, id2.getName()));
        } else {
            sb.append(String.format("\tMOV %s, %s\n", eax.name, id1.getName()));
            sb.append(String.format("\tMOV %s, %s\n", ebx.name, id2.getName()));
        }

        sb.append(String.format("\tPUSH %s\n", ebx.name));
        sb.append(String.format("\tPUSH %s\n", eax.name));
        sb.append(String.format("\t%s\n", macroName));

        Register register = RegisterManager.getGeneralPurpose32(); //Get an available 32 bit register
        Register resultReg = register.getLower();   // Result is stored in lower eight bits
        RegisterManager.freeRegister(register);
        RegisterManager.getRegister(resultReg);     // Reserve the lower register

        mResultRegister = resultReg.name;
        sb.append(String.format("\tPOP %s\n", register));
        return sb.toString();
    }

    /**
     * Get the string to compare the result to boolean true
     * @param label the label to jump to if false
     * @return the string to be appended to the assembly file
     */
    private static String genLastRelationalJump(String label){
        String result = String.format("\tCMP %s, %s\n", mResultRegister, AsmConstants.BOOLEAN_TRUE);
        result += String.format("\tJNE %s\n", label);
        return result;
    }
}
